<!doctype html>
<html lang="en" data-theme="light">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>GeoAI Demo</title>
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css"
        />
        <script src="https://unpkg.com/htmx.org@2.0.4"></script>
        <style>
            body {
                display: flex;
                margin: 0;
                padding: 0;
                height: 100vh;
            }
            .left-panel {
                width: 25%;
                padding: 1rem;
                overflow-y: auto;
            }
            .center-panel {
                width: 50%;
                background-color: #e0e0e0;
                padding: 1rem;
            }
            .right-panel {
                width: 25%;
                padding: 1rem;
                overflow-y: auto;
            }
            textarea[name="filters"] {
                font-family: monospace;
                font-size: small;
            }
            #intent-description {
                font-size: small;
                color: #666;
                margin-bottom: 1rem;
            }
            #sections-container {
                font-size: small;
            }
            .outdated {
                opacity: 0.5;
                font-style: italic;
            }
            .spinner {
                border: 4px solid #f3f3f3;
                border-top: 4px solid #3498db;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
                margin: 2rem auto;
            }
            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }
            .tabs {
                display: flex;
                border-bottom: 2px solid #ccc;
                margin-bottom: 1rem;
                position: relative;
            }
            .tabs .spinner {
                position: absolute;
                right: 10px;
                top: 5px;
                width: 32px;
                height: 32px;
                border: 4px solid #ccc;
                border-top: 4px solid #1a73e8;
                margin: 0;
            }
            .tab {
                padding: 0.5rem 1rem;
                cursor: pointer;
                background-color: #f0f0f0;
                border: none;
                margin-right: 0.25rem;
                color: #333;
            }
            .tab.active {
                background-color: white;
                border-bottom: 2px solid white;
                margin-bottom: -2px;
                color: #000;
            }
            .tab-content {
                display: none;
                position: relative;
            }
            .tab-content.active {
                display: block;
                overflow-y: auto;
                max-height: calc(100vh - 8rem);
                font-size: 0.75rem;
            }
            .export-btn {
                position: absolute;
                top: 0.5rem;
                right: 0.5rem;
                font-size: small;
                z-index: 10;
            }
            /* Lighter, italic placeholder text for all inputs except filters */
            textarea:not([name="filters"])::placeholder,
            input:not([name="filters"])::placeholder {
                color: #999;
                font-style: italic;
                opacity: 1;
            }
            textarea:not([name="filters"])::-webkit-input-placeholder,
            input:not([name="filters"])::-webkit-input-placeholder {
                color: #999;
                font-style: italic;
                opacity: 1;
            }
            textarea:not([name="filters"])::-moz-placeholder,
            input:not([name="filters"])::-moz-placeholder {
                color: #999;
                font-style: italic;
                opacity: 1;
            }
            /* Stats panel styling */
            .stats-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.5rem;
            }
            .stats-header h4 {
                margin: 0;
                font-size: 0.9rem;
            }
            .stats-toggle {
                display: flex;
                gap: 0.25rem;
            }
            .stats-toggle button {
                padding: 0.2rem 0.4rem;
                font-size: 0.7rem;
                background: #e0e0e0;
                border: 1px solid #ccc;
                cursor: pointer;
            }
            .stats-toggle button.active {
                background: #1a73e8;
                color: white;
                border-color: #1a73e8;
            }
            .stats-cards {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
                margin-bottom: 0.75rem;
            }
            .stats-card {
                background: #f8f9fa;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 0.5rem;
                text-align: center;
            }
            .stats-card .label {
                font-size: 0.65rem;
                color: #666;
                text-transform: uppercase;
                margin-bottom: 0.2rem;
            }
            .stats-card .value {
                font-size: 1.1rem;
                font-weight: 600;
                color: #333;
            }
            .stats-section {
                margin-bottom: 0.75rem;
            }
            .stats-section h5 {
                font-size: 0.75rem;
                color: #555;
                margin: 0 0 0.4rem 0;
                border-bottom: 1px solid #e0e0e0;
                padding-bottom: 0.2rem;
            }
            .range-bar {
                position: relative;
                height: 24px;
                background: #e9ecef;
                border-radius: 4px;
                margin: 0.3rem 0;
            }
            .range-bar .range-fill {
                position: absolute;
                height: 100%;
                background: linear-gradient(
                    90deg,
                    #d0ebff 0%,
                    #a5d8ff 50%,
                    #d0ebff 100%
                );
                border-radius: 4px;
            }
            .range-bar.production .range-fill {
                background: linear-gradient(
                    90deg,
                    #d3f9d8 0%,
                    #b2f2bb 50%,
                    #d3f9d8 100%
                );
            }
            .range-bar.lateral .range-fill {
                background: linear-gradient(
                    90deg,
                    #fff3bf 0%,
                    #ffec99 50%,
                    #fff3bf 100%
                );
            }
            .range-bar .range-labels {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 0.4rem;
                font-size: 0.65rem;
            }
            .range-bar .p50-marker {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 2px;
                background: #333;
            }
            .range-bar .p50-label {
                position: absolute;
                top: -14px;
                font-size: 0.6rem;
                color: #333;
                transform: translateX(-50%);
            }
            .stats-table {
                width: 100%;
                font-size: 0.7rem;
                border-collapse: collapse;
            }
            .stats-table th,
            .stats-table td {
                padding: 0.25rem 0.4rem;
                text-align: left;
                border-bottom: 1px solid #e9ecef;
            }
            .stats-table th {
                color: #666;
                font-weight: 500;
            }
            .stats-table .bar-cell {
                width: 40%;
            }
            .stats-table .mini-bar {
                height: 12px;
                background: #4dabf7;
                border-radius: 2px;
            }
            .stats-raw {
                font-family: monospace;
                font-size: 0.65rem;
                background: #f8f9fa;
                padding: 0.5rem;
                overflow-x: auto;
                white-space: pre-wrap;
                overflow-y: auto;
            }
            .well-types {
                display: flex;
                gap: 0.5rem;
                flex-wrap: wrap;
                margin-bottom: 0.5rem;
            }
            .well-type-badge {
                display: inline-flex;
                align-items: center;
                gap: 0.3rem;
                font-size: 0.7rem;
            }
            .well-type-badge .count {
                background: #6c757d;
                color: white;
                padding: 0.1rem 0.4rem;
                border-radius: 10px;
                font-size: 0.65rem;
            }
            .well-type-badge.horizontal .count {
                background: #e67700;
            }
            .well-type-badge.vertical .count {
                background: #1971c2;
            }
            .well-type-badge.deviated .count {
                background: #2f9e44;
            }
            .date-range {
                font-size: 0.7rem;
                color: #555;
            }
            .date-range span {
                display: block;
                margin: 0.2rem 0;
            }
        </style>
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    </head>
    <body>
        <div class="left-panel">
            <details id="init-accordion" open>
                <summary>INITIALIZE</summary>
                <label>
                    Filters
                    <textarea name="filters" rows="15">
[
  {
    "attr": "wh_play.keyword",
    "oper": "filter",
    "type": "terms",
    "value": ["Duvernay"],
    "data_type": "well_header"
  },
  {
    "attr": "data_type.keyword",
    "oper": "filter",
    "type": "term",
    "value": "completion",
    "data_type": "completion"
  },
  {
    "attr": "geometry",
    "data_type": "well_header",
    "oper": "filter",
    "type": "geojson",
    "value": {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "geometry": {
            "type": "Polygon",
            "coordinates": [
              [
                [-13140772.21016681, 7339248.020270397],
                [-12879217.153204478, 7335421.5069953],
                [-12876902.993126694, 7210061.963256612],
                [-13121192.54699089, 7198675.887117638],
                [-13140772.21016681, 7339248.020270397]
              ]
            ]
          },
          "properties": {
            "text": "",
            "textStrokeColor": "rgba(0,0,0,1)",
            "textFillColor": "#000000",
            "textStrokeWidth": 0.4,
            "textScale": 7,
            "textScaleOption": "true",
            "featureFillColor": "rgba(255,0,0,0.5)",
            "featureStrokeColor": "rgba(0,0,0,1)",
            "featurePointType": "default",
            "featureStrokeWidth": 0.4,
            "featureStrokeLineDash": "false",
            "featName": "Polygon2",
            "featureGeometryType": "Polygon",
            "attributes_config": {},
            "aoi": true,
            "featurePointSize": 5,
            "featureRadius": 0,
            "featureId": 2
          },
          "id": 2
        }
      ],
      "projection": "3857"
    }
  }
]</textarea
                    >
                </label>

                <form id="analysis-form">
                    <label>
                        Intent
                        <select name="intent" id="intent-select">
                            <option value="">Loading...</option>
                        </select>
                    </label>
                    <div id="intent-description"></div>
                    <div id="sections-container"></div>

                    <div>
                        <label>Additional Context</label>
                        <small>
                            Provide specific focus or constraints for the
                            analysis.<br />
                            Examples:
                            <ul style="margin: 0.5rem 0; padding-left: 1.5rem">
                                <li>Focus on non-Canadian operators</li>
                                <li>Compare wells before and after 2020</li>
                                <li>
                                    Ignore wells with less than 12 months
                                    production
                                </li>
                            </ul>
                        </small>
                        <textarea
                            name="additional_context"
                            rows="3"
                            placeholder="additional context"
                        ></textarea>
                    </div>

                    <input type="hidden" name="async_mode" value="true" />
                    <input
                        type="hidden"
                        name="return_data_type"
                        value="well_header"
                    />
                    <input
                        type="hidden"
                        name="include_documents"
                        value="false"
                    />

                    <button type="submit">Send to AI</button>
                </form>
            </details>

            <details id="focus-accordion" style="display: none">
                <summary>FOCUS</summary>
                <div id="focus-content">
                    <p>
                        Focus options will appear here after initial analysis
                        completes.
                    </p>
                </div>
            </details>

            <details id="analyze-accordion" style="display: none">
                <summary>ANALYZE</summary>
                <div id="analyze-content">
                    <p>Analysis options will appear here.</p>
                </div>
            </details>
        </div>
        <div class="center-panel">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('geostat')">
                    GEOSTAT
                </button>
                <button
                    id="report-tab-btn"
                    class="tab"
                    onclick="switchTab('report')"
                    style="display: none"
                >
                    REPORT
                </button>
                <button
                    id="explore-tab-btn"
                    class="tab"
                    onclick="switchTab('explore')"
                    style="display: none"
                >
                    EXPLORE
                </button>
            </div>
            <div id="geostat-tab" class="tab-content active">
                <p>Geostat analysis will appear here...</p>
            </div>
            <div id="report-tab" class="tab-content">
                <p>Report will appear here...</p>
            </div>
            <div id="explore-tab" class="tab-content">
                <button
                    id="explore-export-btn"
                    onclick="exportExploreHistory()"
                    class="secondary export-btn"
                >
                    Export
                </button>
                <div
                    id="explore-header"
                    style="
                        padding: 1rem;
                        background: #f5f5f5;
                        border-bottom: 1px solid #ddd;
                    "
                >
                    <h4 style="margin: 0">Explore your filtered dataset</h4>
                </div>
                <div
                    id="explore-messages"
                    style="padding: 1rem; max-height: 60vh; overflow-y: auto"
                >
                    <!-- Messages will appear here -->
                </div>
                <div
                    style="
                        padding: 1rem;
                        border-top: 1px solid #ddd;
                        background: #fafafa;
                    "
                >
                    <div style="display: flex; gap: 0.5rem">
                        <textarea
                            id="explore-input"
                            placeholder="Ask a question about the data..."
                            rows="2"
                            style="flex: 1; resize: vertical"
                        ></textarea>
                        <button
                            id="explore-send"
                            onclick="sendExploreQuery()"
                            disabled
                        >
                            Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <div class="right-panel">
            <details id="logging-accordion" open>
                <summary>LOGGING</summary>
                <textarea
                    id="log-output"
                    readonly
                    rows="30"
                    style="
                        font-family: monospace;
                        font-size: small;
                        width: 100%;
                        resize: vertical;
                    "
                ></textarea>
            </details>

            <details id="profile-accordion">
                <summary>STATS</summary>
                <div id="stats-content">
                    <p style="color: #666; font-size: small">
                        Stats will appear after analysis...
                    </p>
                </div>
            </details>
        </div>

        <dialog id="confirm-modal">
            <article>
                <header>
                    <h3>Confirm Submission</h3>
                </header>
                <pre
                    id="json-preview"
                    style="
                        font-size: small;
                        max-height: 400px;
                        overflow-y: auto;
                    "
                ></pre>
                <footer>
                    <button id="cancel-btn" class="secondary">Cancel</button>
                    <button id="send-btn">Send</button>
                </footer>
            </article>
        </dialog>

        <script>
            let intentsData = [];
            let currentTaskId = null;
            let currentDeepDiveOptions = [];
            let currentRecommendedTopics = [];
            let exploreHistory = [];
            const API_URL =
                "https://dev.geologic.com/api/functions/gemini_api/v3";

            // Tab switching
            function switchTab(tabName) {
                const tabs = document.querySelectorAll(".tab");
                const contents = document.querySelectorAll(".tab-content");

                tabs.forEach((tab) => tab.classList.remove("active"));
                contents.forEach((content) =>
                    content.classList.remove("active"),
                );

                // Find the tab button for this tabName and make it active
                tabs.forEach((tab) => {
                    if (
                        tab.textContent.trim().toLowerCase() ===
                        tabName.toLowerCase()
                    ) {
                        tab.classList.add("active");
                    }
                });
                document
                    .getElementById(tabName + "-tab")
                    .classList.add("active");
            }

            // Load intents on page load from API
            fetch(`${API_URL}/get_intent_ui`)
                .then((response) => response.json())
                .then((response) => {
                    // API wraps response in {data: {...}}
                    const data = response.data || response;
                    intentsData = data.intents || [];
                    const select = document.getElementById("intent-select");
                    select.innerHTML = "";

                    intentsData.forEach((intent, index) => {
                        const option = document.createElement("option");
                        option.value = intent.name;
                        option.textContent = intent.name
                            .replace(/_/g, " ")
                            .replace(/\b\w/g, (l) => l.toUpperCase());
                        select.appendChild(option);
                    });

                    // Trigger change to load first intent (or default)
                    if (intentsData.length > 0) {
                        // Set to default intent if available
                        const defaultIntent =
                            data.default_intent || intentsData[0].name;
                        select.value = defaultIntent;
                        select.dispatchEvent(new Event("change"));
                    }
                });

            // Handle intent selection change
            document
                .getElementById("intent-select")
                .addEventListener("change", function (e) {
                    const selectedIntent = intentsData.find(
                        (i) => i.name === e.target.value,
                    );
                    if (!selectedIntent) return;

                    // Update description
                    document.getElementById("intent-description").textContent =
                        selectedIntent.description;

                    // Update sections checkboxes
                    const sectionsContainer =
                        document.getElementById("sections-container");
                    sectionsContainer.innerHTML =
                        "<fieldset><legend>Sections to Include</legend></fieldset>";
                    const fieldset =
                        sectionsContainer.querySelector("fieldset");

                    const sections = selectedIntent.available_sections || [];
                    sections.forEach((section) => {
                        const label = document.createElement("label");
                        const checkbox = document.createElement("input");
                        checkbox.type = "checkbox";
                        checkbox.name = "section";
                        checkbox.value = section.id;
                        checkbox.checked = true;

                        label.appendChild(checkbox);
                        label.appendChild(
                            document.createTextNode(" " + section.label),
                        );
                        fieldset.appendChild(label);
                    });
                });

            // Handle form submission
            document
                .getElementById("analysis-form")
                .addEventListener("submit", function (e) {
                    e.preventDefault();

                    const formData = new FormData(e.target);

                    // Build JSON payload
                    const payload = {
                        filters: JSON.parse(
                            document.querySelector('textarea[name="filters"]')
                                .value,
                        ),
                        intent: formData.get("intent"),
                        intent_overrides: {
                            sections: {
                                include: formData.getAll("section"),
                            },
                        },
                        additional_context: formData.get("additional_context"),
                        async_mode: formData.get("async_mode") === "true",
                        return_data_type: formData.get("return_data_type"),
                    };

                    // Log payload to console
                    console.log("Sending payload:", payload);

                    // Reset polling state and show spinner
                    lastLogCount = 0;
                    document.getElementById("log-output").value = "";
                    document.getElementById("geostat-tab").innerHTML =
                        '<div class="spinner"></div><p style="text-align: center;">Waiting for analysis...</p>';

                    // Submit directly
                    sendInitialRequest(payload);
                });

            // Polling state
            let pollingInterval = null;
            let lastLogCount = 0;

            function sendInitialRequest(payload) {
                // POST to API
                fetch(API_URL, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(payload),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.task_id) {
                            // Start polling for status (don't close INIT yet)
                            startPolling(data.task_id);
                        } else {
                            // Display response in center panel
                            document.querySelector(".center-panel").innerHTML =
                                '<h2>API Response</h2><pre style="font-size: small; white-space: pre-wrap;">' +
                                JSON.stringify(data, null, 2) +
                                "</pre>";
                        }
                    })
                    .catch((error) => {
                        appendLog("ERROR: " + error.message);
                    });
            }

            function appendLog(message, timestamp) {
                const logOutput = document.getElementById("log-output");
                if (!timestamp) {
                    timestamp = new Date().toLocaleTimeString("en-US", {
                        hour12: false,
                    });
                }
                logOutput.value += `[${timestamp}] ${message}\n`;
                logOutput.scrollTop = logOutput.scrollHeight;
            }

            function startPolling(taskId) {
                currentTaskId = taskId;
                appendLog("Task started: " + taskId);

                // Clear any existing interval
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                }

                // Poll every 3 seconds
                pollingInterval = setInterval(() => {
                    fetch(`${API_URL}/status/${taskId}`)
                        .then((response) => response.json())
                        .then((response) => {
                            console.log("Poll response:", response);
                            const data = response.data || response;
                            const logs = data.logs || [];

                            // Append only new log messages
                            for (let i = lastLogCount; i < logs.length; i++) {
                                const log = logs[i];
                                let timestamp;
                                if (log.timestamp) {
                                    timestamp = new Date(
                                        log.timestamp,
                                    ).toLocaleTimeString("en-US", {
                                        hour12: false,
                                    });
                                } else {
                                    timestamp = new Date().toLocaleTimeString(
                                        "en-US",
                                        {
                                            hour12: false,
                                        },
                                    );
                                }
                                appendLog(log.message, timestamp);
                            }
                            lastLogCount = logs.length;

                            // Check for focus checkpoint with geostat_analysis
                            const latestMessage =
                                logs.length > 0
                                    ? logs[logs.length - 1].message
                                    : "";
                            // Display geostat_analysis if available
                            if (data.geostat_analysis) {
                                const geostatTab =
                                    document.getElementById("geostat-tab");
                                const title =
                                    data.status === "awaiting_focus"
                                        ? "<h2>Focus Summary</h2>"
                                        : "<h2>Geostat Analysis</h2>";
                                geostatTab.innerHTML =
                                    '<div style="padding: 1rem;">' +
                                    title +
                                    marked.parse(data.geostat_analysis) +
                                    "</div>";

                                // Remove outdated class and spinner if they exist (new content arrived)
                                geostatTab
                                    .querySelector("div")
                                    .classList.remove("outdated");
                                const tabsContainer =
                                    document.querySelector(".tabs");
                                const spinner =
                                    tabsContainer.querySelector(".spinner");
                                if (spinner) spinner.remove();
                            }

                            if (
                                latestMessage === "Focus checkpoint reached" &&
                                data.status === "awaiting_focus"
                            ) {
                                // Stop polling
                                clearInterval(pollingInterval);
                                pollingInterval = null;

                                appendLog("Focus checkpoint reached");

                                // Close INIT accordion, open FOCUS accordion
                                document.getElementById("init-accordion").open =
                                    false;
                                document.getElementById(
                                    "focus-accordion",
                                ).open = true;

                                // Populate FOCUS accordion
                                populateFocusForm(data);
                            }

                            // Check if task is complete (terminal states)
                            const status = data.status;
                            if (
                                status === "completed" ||
                                status === "awaiting_selection"
                            ) {
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                                appendLog(
                                    "Analysis complete - status: " + status,
                                );
                                console.log("Final status object:", data);

                                // Handle synthesis completion
                                handleSynthesisComplete(data);
                            } else if (
                                status === "failed" ||
                                status === "no_data"
                            ) {
                                clearInterval(pollingInterval);
                                pollingInterval = null;
                                appendLog(
                                    "Task finished with status: " + status,
                                );
                            }
                        })
                        .catch((error) => {
                            console.error("Polling error:", error);
                            clearInterval(pollingInterval);
                            pollingInterval = null;
                            appendLog("Polling failed: " + error.message);
                        });
                }, 3000);
            }

            function populateFocusForm(data) {
                const focusContent = document.getElementById("focus-content");

                //let html = "<h4>Focus Options</h4>";
                let html = "";

                // Focus history
                if (data.focus_history && data.focus_history.length > 0) {
                    html += "<h5>Focus History</h5><ul>";
                    data.focus_history.forEach((item) => {
                        const prompt = item.prompt || item.focus_prompt || item;
                        const desc = item.description || "";
                        const impact = item.estimated_impact || "";
                        let summary = `Round ${item.round || ""}: "${prompt}"`;
                        if (desc) summary += ` - ${desc}`;
                        if (impact) summary += ` (${impact})`;
                        html += `<li>${summary}</li>`;
                    });
                    html += "</ul>";
                }

                // Examples
                if (data.focus_examples && data.focus_examples.length > 0) {
                    html += "<h5>Optional Focus Prompts</h5><ul>";
                    data.focus_examples.forEach((example) => {
                        html += `<li>${example}</li>`;
                    });
                    html += "</ul>";
                }

                // Focus form
                html += `
                    <label>
                        <textarea id="focus-prompt" name="focus" rows="3" placeholder="filter prompt..."></textarea>
                    </label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button id="focus-btn" class="secondary" disabled onclick="submitFocus()">Apply Focus</button>
                        <span style="color: #666; font-size: small;">or</span>
                        <button id="continue-btn" onclick="submitContinue()">Continue to Report</button>
                    </div>
                `;

                focusContent.innerHTML = html;

                // Enable/disable Focus button based on text input
                document
                    .getElementById("focus-prompt")
                    .addEventListener("input", function (e) {
                        const focusBtn = document.getElementById("focus-btn");
                        focusBtn.disabled = e.target.value.trim() === "";
                    });

                // Show FOCUS accordion, open it, and close INITIALIZE
                const focusAccordion =
                    document.getElementById("focus-accordion");
                const initAccordion = document.getElementById("init-accordion");
                focusAccordion.style.display = "";
                focusAccordion.open = true;
                initAccordion.open = false;
            }

            function submitFocus() {
                const focusPrompt = document
                    .getElementById("focus-prompt")
                    .value.trim();
                if (!focusPrompt) return;

                appendLog("Applying focus: " + focusPrompt);

                // Mark GEOSTAT tab as outdated and add spinner
                const geostatTab = document.getElementById("geostat-tab");
                const geostatDiv = geostatTab.querySelector("div");
                geostatDiv.classList.add("outdated");

                // Add spinner to tabs container
                const tabsContainer = document.querySelector(".tabs");
                if (!tabsContainer.querySelector(".spinner")) {
                    const spinner = document.createElement("div");
                    spinner.className = "spinner";
                    spinner.id = "tab-spinner";
                    tabsContainer.appendChild(spinner);
                }

                const payload = {
                    task_id: currentTaskId,
                    action: "focus",
                    focus_prompt: focusPrompt,
                    async_mode: true,
                };

                // Reset polling state
                lastLogCount = 0;

                // POST focus
                fetch(API_URL, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(payload),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.task_id) {
                            // Start polling again
                            startPolling(data.task_id);
                        } else {
                            appendLog("Error: No task_id returned");
                        }
                    })
                    .catch((error) => {
                        appendLog("ERROR: " + error.message);
                    });
            }

            function submitContinue() {
                appendLog("Continuing to synthesis");

                // Mark GEOSTAT tab as outdated and add spinner
                const geostatTab = document.getElementById("geostat-tab");
                const geostatDiv = geostatTab.querySelector("div");
                geostatDiv.classList.add("outdated");

                // Add spinner to tabs container
                const tabsContainer = document.querySelector(".tabs");
                if (!tabsContainer.querySelector(".spinner")) {
                    const spinner = document.createElement("div");
                    spinner.className = "spinner";
                    spinner.id = "tab-spinner";
                    tabsContainer.appendChild(spinner);
                }

                const payload = {
                    task_id: currentTaskId,
                    action: "continue",
                    async_mode: true,
                };

                // Reset polling state
                lastLogCount = 0;

                // POST continue
                fetch(API_URL, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(payload),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.task_id) {
                            // Start polling again
                            startPolling(data.task_id);
                        } else {
                            appendLog("Error: No task_id returned");
                        }
                    })
                    .catch((error) => {
                        appendLog("ERROR: " + error.message);
                    });
            }

            function handleSynthesisComplete(data) {
                // Close FOCUS accordion, open ANALYZE accordion
                document.getElementById("focus-accordion").open = false;
                document.getElementById("analyze-accordion").open = true;

                // Populate STATS accordion
                const report = data.report || {};
                const profileStats = report.sections?.profile_stats || {};
                renderStatsPanel(profileStats);

                // Expand STATS accordion when first populated
                document.getElementById("profile-accordion").open = true;

                // Update GEOSTAT tab with full geostat_summary
                const geostatSummary = report.sections?.geostat_summary || "";
                const geostatTab = document.getElementById("geostat-tab");
                geostatTab.innerHTML =
                    '<button onclick="exportGeostat()" class="secondary export-btn">Export</button>' +
                    '<div style="padding: 1rem;">' +
                    "<h2>Geostat Analysis</h2>" +
                    marked.parse(geostatSummary) +
                    "</div>";

                // Remove outdated class and spinner if they exist (new content arrived)
                geostatTab.querySelector("div").classList.remove("outdated");
                const tabsContainer2 = document.querySelector(".tabs");
                const spinner2 = tabsContainer2.querySelector(".spinner");
                if (spinner2) spinner2.remove();

                // Update REPORT tab and switch to it
                populateReportTab(data);
                switchTab("report");

                // Populate ANALYZE accordion
                populateAnalyzeForm(data);

                // Enable EXPLORE tab
                enableExplore();
            }

            function populateReportTab(data) {
                const report = data.report || {};
                const reportTab = document.getElementById("report-tab");

                let html =
                    '<button onclick="exportReport()" class="secondary export-btn">Export</button>';
                html += '<div style="padding: 1rem;">';
                html += "<h2>Analysis Report</h2>";

                // Additional context
                if (report.additional_context) {
                    html += "<h3>Additional Context</h3>";
                    html += "<p>" + report.additional_context + "</p>";
                }

                // Filters
                if (report.filters && report.filters.length > 0) {
                    html += "<h3>Filters</h3><ul>";
                    report.filters.forEach((filter) => {
                        html += "<li>" + filter + "</li>";
                    });
                    html += "</ul>";
                }

                // Main report markdown
                if (report.markdown) {
                    html += marked.parse(report.markdown);
                }

                // Timing
                if (report.timing) {
                    html +=
                        "<h3>Timing</h3><pre>" +
                        JSON.stringify(report.timing, null, 2) +
                        "</pre>";
                }

                // Tokens
                if (report.tokens) {
                    html +=
                        "<h3>Tokens</h3><pre>" +
                        JSON.stringify(report.tokens, null, 2) +
                        "</pre>";
                }

                html += "</div>";
                reportTab.innerHTML = html;

                // Remove outdated class and spinner if they exist (new content arrived)
                const reportDiv = reportTab.querySelector("div");
                if (reportDiv) {
                    reportDiv.classList.remove("outdated");
                }
                const tabsContainer3 = document.querySelector(".tabs");
                const spinner3 = tabsContainer3.querySelector(".spinner");
                if (spinner3) spinner3.remove();
            }

            function populateAnalyzeForm(data) {
                const analyzeContent =
                    document.getElementById("analyze-content");
                const deepDiveOptions = data.deep_dive_options || [];
                const recommendedTopics = data.recommended_topics || [];

                // Store globally for later updates
                currentDeepDiveOptions = deepDiveOptions;
                currentRecommendedTopics = recommendedTopics;

                renderAnalyzeAccordion(deepDiveOptions, recommendedTopics);
            }

            function renderAnalyzeAccordion(
                deepDiveOptions,
                recommendedTopics,
            ) {
                const analyzeContent =
                    document.getElementById("analyze-content");

                let html = "<h5>Deep-Dive Topics</h5>";
                html +=
                    '<p style="font-size: small;">Data availability: <span style="color: #22c55e; font-weight: bold;">●</span> &gt;80% &nbsp; <span style="color: #f59e0b; font-weight: bold;">●</span> 50-80% &nbsp; <span style="color: #ef4444; font-weight: bold;">●</span> 20-50%</p>';
                html += "<hr>";

                if (deepDiveOptions.length > 0) {
                    deepDiveOptions.forEach((option, index) => {
                        const availability = (
                            option.availability || ""
                        ).toUpperCase();
                        const name = option.name || option.key || "";
                        const description = option.description || "";

                        // Map availability to color
                        let color = "#999"; // default
                        if (availability === "HIGH")
                            color = "#22c55e"; // green
                        else if (availability === "MEDIUM")
                            color = "#f59e0b"; // orange
                        else if (availability === "LOW") color = "#ef4444"; // red

                        html += `
                            <label style="display: block; margin-bottom: 0.5rem;">
                                <input type="checkbox" class="deep-dive-option"
                                    data-prompt="${option.prompt || ""}"
                                    data-key="${option.key || option.section_key || ""}"
                                    value="${name}">
                                <span style="color: ${color}; font-weight: bold; font-size: 1.2em;">●</span> ${name}<br>
                                <span style="margin-left: 2rem; font-size: small; color: #666;">${description}</span>
                            </label>
                        `;
                    });
                }

                html += "<h5>Recommended Topics</h5>";
                if (recommendedTopics.length > 0) {
                    recommendedTopics.forEach((topic) => {
                        const availability = (
                            topic.availability || ""
                        ).toUpperCase();
                        const name = topic.name || topic.key || "";
                        const description = topic.description || "";

                        // Map availability to color (same as deep-dive)
                        let color = "#999"; // default
                        if (availability === "HIGH")
                            color = "#22c55e"; // green
                        else if (availability === "MEDIUM")
                            color = "#f59e0b"; // orange
                        else if (availability === "LOW") color = "#ef4444"; // red

                        html += `
                            <label style="display: block; margin-bottom: 0.5rem;">
                                <input type="checkbox" class="recommended-topic"
                                    data-prompt="${topic.prompt || ""}"
                                    data-key="${topic.key || ""}"
                                    value="${name}">
                                <span style="color: ${color}; font-weight: bold; font-size: 1.2em;">●</span> ${name}<br>
                                <span style="margin-left: 2rem; font-size: small; color: #666;">${description}</span>
                            </label>
                        `;
                    });
                }

                html += `
                    <label>
                        <h5>Custom Topic</h5>
                        <textarea id="custom-topic" rows="3" placeholder="Enter custom analysis topic..."></textarea>
                    </label>
                    <button onclick="appendSections()">Append Sections</button>
                `;

                analyzeContent.innerHTML = html;

                // Show ANALYZE accordion, open it, and close INITIALIZE and FOCUS
                const analyzeAccordion =
                    document.getElementById("analyze-accordion");
                const initAccordion = document.getElementById("init-accordion");
                const focusAccordion =
                    document.getElementById("focus-accordion");
                analyzeAccordion.style.display = "";
                analyzeAccordion.open = true;
                initAccordion.open = false;
                focusAccordion.open = false;

                // Show REPORT and EXPLORE tabs in center panel
                document.getElementById("report-tab-btn").style.display = "";
                document.getElementById("explore-tab-btn").style.display = "";
            }

            function appendSections() {
                const deepDiveCheckboxes = document.querySelectorAll(
                    ".deep-dive-option:checked",
                );
                const recommendedCheckboxes = document.querySelectorAll(
                    ".recommended-topic:checked",
                );
                const customTopic = document
                    .getElementById("custom-topic")
                    .value.trim();

                // Collect all items to submit
                const itemsToSubmit = [];

                deepDiveCheckboxes.forEach((checkbox) => {
                    itemsToSubmit.push({
                        payload: {
                            task_id: currentTaskId,
                            user_prompt: checkbox.dataset.prompt,
                            section_key: checkbox.dataset.key,
                            is_followup: true,
                        },
                        label: checkbox.value,
                    });
                });

                recommendedCheckboxes.forEach((checkbox) => {
                    itemsToSubmit.push({
                        payload: {
                            task_id: currentTaskId,
                            user_prompt: checkbox.dataset.prompt,
                            section_key: checkbox.dataset.key,
                            is_followup: true,
                        },
                        label: checkbox.value,
                    });
                });

                if (customTopic) {
                    itemsToSubmit.push({
                        payload: {
                            task_id: currentTaskId,
                            user_prompt: customTopic,
                            section_key: "custom_analysis",
                            is_followup: true,
                        },
                        label: "Custom Topic",
                    });
                }

                // Nothing to submit
                if (itemsToSubmit.length === 0) {
                    appendLog("No items selected to append");
                    return;
                }

                // Mark REPORT tab as outdated and add spinner
                const reportTab = document.getElementById("report-tab");
                const reportDiv = reportTab.querySelector("div");
                if (reportDiv) {
                    reportDiv.classList.add("outdated");

                    // Add spinner to tabs container
                    const tabsContainer = document.querySelector(".tabs");
                    if (!tabsContainer.querySelector(".spinner")) {
                        const spinner = document.createElement("div");
                        spinner.className = "spinner";
                        spinner.id = "tab-spinner";
                        tabsContainer.appendChild(spinner);
                    }
                }

                // Reset polling state
                lastLogCount = 0;

                // Track pending requests
                let pendingRequests = itemsToSubmit.length;

                // Track completed responses for appending to report
                const completedResponses = [];

                // Submit all items
                itemsToSubmit.forEach((item) => {
                    appendLog("Submitting: " + item.label);
                    console.log("[POST]", API_URL, item.payload);

                    fetch(API_URL, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(item.payload),
                    })
                        .then((response) => response.json())
                        .then((data) => {
                            // Follow-up responses are synchronous - they return immediately with content
                            if (
                                data.is_followup &&
                                data.Analysis &&
                                data.Analysis.response
                            ) {
                                const timing =
                                    data.timing?.followup_seconds || 0;
                                appendLog(
                                    "Completed '" +
                                        item.label +
                                        "' (" +
                                        timing.toFixed(1) +
                                        "s)",
                                );
                                completedResponses.push({
                                    label: item.label,
                                    content:
                                        data.Analysis.response_display ||
                                        data.Analysis.response,
                                });

                                // Update deep-dive and recommended options if provided
                                if (data.deep_dive_options) {
                                    currentDeepDiveOptions =
                                        data.deep_dive_options;
                                }
                                if (data.recommended_topics) {
                                    currentRecommendedTopics =
                                        data.recommended_topics;
                                }
                            } else {
                                appendLog(
                                    "Response for '" +
                                        item.label +
                                        "': " +
                                        (data.status || "ok"),
                                );
                            }
                            pendingRequests--;

                            // When all requests are done, update the UI
                            if (pendingRequests === 0) {
                                appendLog("All sections completed");
                                finishFollowupRequests(completedResponses);
                            }
                        })
                        .catch((error) => {
                            appendLog(
                                "ERROR '" + item.label + "': " + error.message,
                            );
                            pendingRequests--;

                            if (pendingRequests === 0) {
                                finishFollowupRequests(completedResponses);
                            }
                        });
                });
            }

            function finishFollowupRequests(completedResponses) {
                // Remove spinner
                const spinner = document.getElementById("tab-spinner");
                if (spinner) spinner.remove();

                // Remove outdated styling from report
                const reportTab = document.getElementById("report-tab");
                const reportDiv = reportTab.querySelector("div");
                if (reportDiv) {
                    reportDiv.classList.remove("outdated");
                }

                // Append completed sections to the report
                if (completedResponses.length > 0) {
                    let reportContent = reportDiv ? reportDiv.innerHTML : "";

                    completedResponses.forEach((resp) => {
                        // Add section header and content
                        reportContent += `\n\n<h2>${resp.label}</h2>\n${marked.parse(resp.content)}`;
                    });

                    if (reportDiv) {
                        reportDiv.innerHTML = reportContent;
                    }

                    appendLog(
                        "Report updated with " +
                            completedResponses.length +
                            " new section(s)",
                    );
                }

                // Refresh the ANALYZE accordion with updated options
                if (currentDeepDiveOptions || currentRecommendedTopics) {
                    renderAnalyzeAccordion(
                        currentDeepDiveOptions || [],
                        currentRecommendedTopics || [],
                    );
                }
            }

            function enableExplore() {
                // Enable the send button
                document.getElementById("explore-send").disabled = false;

                // Enable Enter key to send (only add listener once)
                const input = document.getElementById("explore-input");
                if (!input.dataset.listenerAdded) {
                    input.addEventListener("keydown", function (e) {
                        if (e.key === "Enter" && !e.shiftKey) {
                            e.preventDefault();
                            sendExploreQuery();
                        }
                    });
                    input.dataset.listenerAdded = "true";
                }
            }

            function sendExploreQuery() {
                const input = document.getElementById("explore-input");
                const question = input.value.trim();

                if (!question || !currentTaskId) return;

                // Add user message to chat
                addExploreMessage("user", question);

                // Clear input
                input.value = "";

                // Replace Send button with spinner
                const sendBtn = document.getElementById("explore-send");
                const originalText = sendBtn.textContent;
                sendBtn.innerHTML = '<div class="spinner"></div>';
                sendBtn.disabled = true;

                // Send query
                fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        task_id: currentTaskId,
                        action: "query",
                        question: question,
                        history: exploreHistory,
                    }),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        // Restore button
                        sendBtn.innerHTML = originalText;
                        sendBtn.disabled = false;

                        const answer =
                            data.answer ||
                            data.data?.answer ||
                            "No response received.";

                        // Add assistant response
                        addExploreMessage("assistant", answer);

                        // Update history
                        exploreHistory.push({
                            role: "user",
                            content: question,
                        });
                        exploreHistory.push({
                            role: "assistant",
                            content: answer,
                        });

                        // Log the interaction
                        appendLog(
                            `Query sent: ${question.substring(0, 50)}${question.length > 50 ? "..." : ""}`,
                        );
                    })
                    .catch((error) => {
                        // Restore button
                        sendBtn.innerHTML = originalText;
                        sendBtn.disabled = false;

                        addExploreMessage(
                            "assistant",
                            `Error: ${error.message}`,
                        );
                        appendLog(`ERROR: ${error.message}`);
                    });
            }

            let messageIdCounter = 0;
            function addExploreMessage(role, content, isTemporary = false) {
                const messagesDiv = document.getElementById("explore-messages");
                const messageId = `msg-${messageIdCounter++}`;

                const messageDiv = document.createElement("div");
                messageDiv.id = messageId;
                messageDiv.style.marginBottom = "1rem";
                messageDiv.style.padding = "0.75rem";
                messageDiv.style.borderRadius = "0.5rem";

                if (role === "user") {
                    messageDiv.style.background = "#e3f2fd";
                    messageDiv.style.marginLeft = "2rem";
                    messageDiv.innerHTML = `<div style="font-weight: bold; margin-bottom: 0.25rem; color: #1976d2;">You:</div><div>${escapeHtml(content)}</div>`;
                } else {
                    messageDiv.style.background = isTemporary
                        ? "#fff3cd"
                        : "#f5f5f5";
                    messageDiv.style.marginRight = "2rem";
                    messageDiv.innerHTML = `<div style="font-weight: bold; margin-bottom: 0.25rem; color: #555;">Assistant:</div><div>${marked.parse(content)}</div>`;
                }

                messagesDiv.appendChild(messageDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;

                return messageId;
            }

            function removeExploreMessage(messageId) {
                const messageDiv = document.getElementById(messageId);
                if (messageDiv) {
                    messageDiv.remove();
                }
            }

            // Store raw stats for toggle
            let rawProfileStats = {};

            function renderStatsPanel(stats) {
                rawProfileStats = stats;
                const container = document.getElementById("stats-content");

                if (!stats || Object.keys(stats).length === 0) {
                    container.innerHTML =
                        '<p style="color: #666; font-size: small;">No stats available.</p>';
                    return;
                }

                const summary = stats.summary || {};
                const production = stats.production || {};
                const operators = stats.operators || {};
                const depth = stats.depth || {};
                const descriptions = stats.category_descriptions || {};

                let html = "";

                // Header with toggle buttons
                html += `
                    <div class="stats-header">
                        <h4>Profile Data</h4>
                        <div class="stats-toggle">
                            <button class="active" onclick="showStatsView('visual')">Visual</button>
                            <button onclick="showStatsView('raw')">JSON</button>
                        </div>
                    </div>
                `;

                html += '<div id="stats-visual-view">';

                // Summary cards
                html += '<div class="stats-cards">';
                html += `<div class="stats-card"><div class="label">Total Wells</div><div class="value">${formatNumber(summary.total_wells)}</div></div>`;
                html += `<div class="stats-card"><div class="label">Operators</div><div class="value">${formatNumber(summary.unique_operators)}</div></div>`;
                html += `<div class="stats-card"><div class="label">Formations</div><div class="value">${formatNumber(summary.unique_formations)}</div></div>`;
                html += `<div class="stats-card"><div class="label">Fields</div><div class="value">${formatNumber(summary.unique_fields)}</div></div>`;
                html += "</div>";

                // Well types
                if (
                    summary.horizontal_wells ||
                    summary.vertical_wells ||
                    summary.deviated_wells
                ) {
                    html += '<div class="stats-section"><h5>Well Types</h5>';
                    html += '<div class="well-types">';
                    if (summary.horizontal_wells)
                        html += `<span class="well-type-badge horizontal"><span class="count">${summary.horizontal_wells}</span> Horizontal</span>`;
                    if (summary.vertical_wells)
                        html += `<span class="well-type-badge vertical"><span class="count">${summary.vertical_wells}</span> Vertical</span>`;
                    if (summary.deviated_wells)
                        html += `<span class="well-type-badge deviated"><span class="count">${summary.deviated_wells}</span> Deviated</span>`;
                    html += "</div></div>";
                }

                // Date range
                if (summary.earliest_spud || summary.latest_spud) {
                    html += '<div class="stats-section"><h5>Date Range</h5>';
                    html += '<div class="date-range">';
                    if (summary.earliest_spud)
                        html += `<span>Earliest: ${summary.earliest_spud}</span>`;
                    if (summary.latest_spud)
                        html += `<span>Latest: ${summary.latest_spud}</span>`;
                    html += "</div></div>";
                }

                // Production P10/P50/P90
                if (production.boe) {
                    html +=
                        '<div class="stats-section"><h5>Production (BOE)</h5>';
                    html += renderRangeBar(
                        production.boe.p10,
                        production.boe.p50,
                        production.boe.p90,
                        "production",
                    );
                    html += "</div>";
                }

                // Depth/Lateral length
                if (depth.lateral_length) {
                    html +=
                        '<div class="stats-section"><h5>Lateral Length (m)</h5>';
                    html += renderRangeBar(
                        depth.lateral_length.p10,
                        depth.lateral_length.p50,
                        depth.lateral_length.p90,
                        "lateral",
                    );
                    html += "</div>";
                }

                // Top operators
                if (
                    operators.top_operators &&
                    operators.top_operators.length > 0
                ) {
                    const maxWells = Math.max(
                        ...operators.top_operators.map(
                            (o) => o.well_count || 0,
                        ),
                    );
                    html += '<div class="stats-section"><h5>Top Operators</h5>';
                    html +=
                        '<table class="stats-table"><thead><tr><th>Operator</th><th>Wells</th><th class="bar-cell"></th></tr></thead><tbody>';
                    operators.top_operators.slice(0, 5).forEach((op) => {
                        const pct =
                            maxWells > 0
                                ? ((op.well_count || 0) / maxWells) * 100
                                : 0;
                        html += `<tr>
                            <td>${escapeHtml(op.name || op.operator || "Unknown")}</td>
                            <td>${op.well_count || 0}</td>
                            <td class="bar-cell"><div class="mini-bar" style="width: ${pct}%"></div></td>
                        </tr>`;
                    });
                    html += "</tbody></table></div>";
                }

                html += "</div>"; // end stats-visual-view

                // Raw JSON view (hidden by default)
                html += `<div id="stats-raw-view" style="display: none;"><pre class="stats-raw">${escapeHtml(JSON.stringify(stats, null, 2))}</pre></div>`;

                container.innerHTML = html;
            }

            function showStatsView(view) {
                const visualView = document.getElementById("stats-visual-view");
                const rawView = document.getElementById("stats-raw-view");
                const buttons = document.querySelectorAll(
                    ".stats-toggle button",
                );

                buttons.forEach((btn) => btn.classList.remove("active"));

                if (view === "raw") {
                    visualView.style.display = "none";
                    rawView.style.display = "block";
                    buttons[1].classList.add("active");
                } else {
                    visualView.style.display = "block";
                    rawView.style.display = "none";
                    buttons[0].classList.add("active");
                }
            }

            function renderRangeBar(p10, p50, p90, type = "") {
                if (p10 == null || p90 == null) return "";

                // Calculate positions as percentages
                const range = p90 - p10;
                const p50Pct = range > 0 ? ((p50 - p10) / range) * 100 : 50;

                return `
                    <div class="range-bar ${type}">
                        <div class="range-fill" style="left: 0; width: 100%;"></div>
                        <div class="p50-marker" style="left: ${p50Pct}%;">
                            <span class="p50-label">P50: ${formatNumber(p50)}</span>
                        </div>
                        <div class="range-labels">
                            <span>P10: ${formatNumber(p10)}</span>
                            <span>P90: ${formatNumber(p90)}</span>
                        </div>
                    </div>
                `;
            }

            function formatNumber(num) {
                if (num == null) return "-";
                if (typeof num !== "number") return num;
                if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
                if (num >= 1000) return (num / 1000).toFixed(1) + "K";
                return num.toLocaleString();
            }

            function escapeHtml(text) {
                const div = document.createElement("div");
                div.textContent = text;
                return div.innerHTML;
            }

            function downloadMarkdown(filename, content) {
                const blob = new Blob([content], { type: "text/markdown" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function exportExploreHistory() {
                if (exploreHistory.length === 0) {
                    alert("No conversation to export.");
                    return;
                }

                const timestamp = new Date()
                    .toISOString()
                    .slice(0, 19)
                    .replace(/[T:]/g, "-");
                let markdown = `# Explore Session\n\nExported: ${new Date().toLocaleString()}\n\n---\n\n`;

                for (let i = 0; i < exploreHistory.length; i += 2) {
                    const userMsg = exploreHistory[i];
                    const assistantMsg = exploreHistory[i + 1];

                    markdown += `## Q: ${userMsg.content}\n\n`;
                    if (assistantMsg) {
                        markdown += `${assistantMsg.content}\n\n---\n\n`;
                    }
                }

                downloadMarkdown(`explore-${timestamp}.md`, markdown);
                appendLog("Exported explore history to markdown");
            }

            function exportReport() {
                const reportTab = document.getElementById("report-tab");
                const reportDiv = reportTab.querySelector("div");
                if (!reportDiv || !reportDiv.textContent.trim()) {
                    alert("No report to export.");
                    return;
                }

                const timestamp = new Date()
                    .toISOString()
                    .slice(0, 19)
                    .replace(/[T:]/g, "-");

                // Get the raw markdown from the report sections if available
                // For now, extract text content and structure it
                let markdown = `# Analysis Report\n\nExported: ${new Date().toLocaleString()}\n\n---\n\n`;

                // Walk through the report HTML and extract content
                const headers = reportDiv.querySelectorAll("h1, h2, h3, h4");
                if (headers.length > 0) {
                    headers.forEach((header) => {
                        const level = parseInt(header.tagName[1]);
                        const prefix = "#".repeat(level);
                        markdown += `${prefix} ${header.textContent}\n\n`;

                        // Get content until next header
                        let sibling = header.nextElementSibling;
                        while (sibling && !sibling.matches("h1, h2, h3, h4")) {
                            if (sibling.textContent.trim()) {
                                markdown += `${sibling.textContent.trim()}\n\n`;
                            }
                            sibling = sibling.nextElementSibling;
                        }
                    });
                } else {
                    markdown += reportDiv.textContent;
                }

                downloadMarkdown(`report-${timestamp}.md`, markdown);
                appendLog("Exported report to markdown");
            }

            function exportGeostat() {
                const geostatTab = document.getElementById("geostat-tab");
                const geostatDiv = geostatTab.querySelector("div");
                if (!geostatDiv || !geostatDiv.textContent.trim()) {
                    alert("No geostat analysis to export.");
                    return;
                }

                const timestamp = new Date()
                    .toISOString()
                    .slice(0, 19)
                    .replace(/[T:]/g, "-");

                let markdown = `# Geostat Analysis\n\nExported: ${new Date().toLocaleString()}\n\n---\n\n`;

                // Walk through the geostat HTML and extract content
                const headers = geostatDiv.querySelectorAll("h1, h2, h3, h4");
                if (headers.length > 0) {
                    headers.forEach((header) => {
                        const level = parseInt(header.tagName[1]);
                        const prefix = "#".repeat(level);
                        markdown += `${prefix} ${header.textContent}\n\n`;

                        // Get content until next header
                        let sibling = header.nextElementSibling;
                        while (sibling && !sibling.matches("h1, h2, h3, h4")) {
                            if (sibling.textContent.trim()) {
                                markdown += `${sibling.textContent.trim()}\n\n`;
                            }
                            sibling = sibling.nextElementSibling;
                        }
                    });
                } else {
                    markdown += geostatDiv.textContent;
                }

                downloadMarkdown(`geostat-${timestamp}.md`, markdown);
                appendLog("Exported geostat to markdown");
            }

            function startFollowupPolling() {
                // Poll for status until completed or awaiting_selection
                const pollInterval = setInterval(() => {
                    fetch(`${API_URL}?task_id=${currentTaskId}`)
                        .then((response) => response.json())
                        .then((response) => {
                            const data = response.data || response;
                            const status = data.status;
                            const logs = data.logs || [];

                            // Display new log entries
                            if (logs.length > lastLogCount) {
                                for (
                                    let i = lastLogCount;
                                    i < logs.length;
                                    i++
                                ) {
                                    const log = logs[i];
                                    const timestamp = log.timestamp
                                        ? new Date(
                                              log.timestamp,
                                          ).toLocaleTimeString()
                                        : "";
                                    appendLog(log.message, timestamp);
                                }
                                lastLogCount = logs.length;
                            }

                            // Check for completion
                            if (
                                status === "completed" ||
                                status === "awaiting_selection"
                            ) {
                                clearInterval(pollInterval);
                                appendLog(
                                    "Followup analysis complete - status: " +
                                        status,
                                );
                                console.log("Final status object:", data);

                                // Update REPORT tab with new content
                                if (data.report) {
                                    populateReportTab(data);
                                }

                                // Remove spinner and outdated state
                                const reportTab =
                                    document.getElementById("report-tab");
                                const reportDiv =
                                    reportTab.querySelector("div");
                                if (reportDiv) {
                                    reportDiv.classList.remove("outdated");
                                }
                                const tabsContainer =
                                    document.querySelector(".tabs");
                                const spinner =
                                    tabsContainer.querySelector(".spinner");
                                if (spinner) spinner.remove();
                            } else if (
                                status === "error" ||
                                status === "failed"
                            ) {
                                clearInterval(pollInterval);
                                appendLog(
                                    "ERROR: " + (data.error || "Unknown error"),
                                );

                                // Remove spinner
                                const tabsContainer =
                                    document.querySelector(".tabs");
                                const spinner =
                                    tabsContainer.querySelector(".spinner");
                                if (spinner) spinner.remove();
                            }
                        })
                        .catch((error) => {
                            appendLog("Polling error: " + error.message);
                        });
                }, 2000); // Poll every 2 seconds
            }
        </script>
    </body>
</html>
